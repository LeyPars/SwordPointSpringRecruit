/*
//redis相关数据结构

1.dict/hash 字典/哈希
2.sds:simple dynamic string
3:intset:整数集合
4.quicklist/ziplist:快速列表/压缩列表
5.skiplist：跳表
6.bitmap：位图
7.HyberLogLog：基数统计 12k内存统计2^64个不同元素的基数
	基本原理：维护了16384个桶，每添加一个元素，通过哈希函数计算一个哈希值，此哈希值为64位的01比特流，
	         其中低14位比特流用来确定放到哪一个桶中，高50位第一次出现1的位置记录在桶中，每个桶的大小
			 为6bit,桶的数量为2^14 = 16384,每个桶储存最大后续0的位数，最后通过计算所有桶的一个调和平均，
			 估算基数的大小。
	说明：https://mp.weixin.qq.com/s/AvPoG8ZZM8v9lKLyuSYnHQ
		 https://www.zhihu.com/question/53416615/answer/1227317241
		 https://blog.csdn.net/u013474436/article/details/88945767
8.布隆过滤器：位数组，初始化指定错误率与预估数据量


//redis相关说明
1.限流算法：时间滑动窗口限流（高qps下占用内存太大）
           漏斗算法（稳定内存占比）
2.GeoHash算法：二维平面映射成一维的线，切蛋糕编码，之后对这个整数做一次base32编码，内部结构是一个zset
  说明：https://www.jianshu.com/p/2fd0cf12e5ba
  步骤：
		第一步：将经纬度按照切蛋糕编码编码为二进制
		第二步：合并经纬度，分别为奇数位和偶数位
		第三步：将第二步的二进制数转成十进制然后进行base32编码
3.大海捞针：scan：使用 游标 + 正则表达 + 遍历的slot数量
        说明：1.使用高位加法来遍历槽slot，考虑到扩容与缩容，扩容前后的分散在高位加法下是相邻的
		     2.需要客户端将cursor传入，服务端并不保存游标
4.序列化协议RESP:1.实现简单，解析性能好
                2.拥有大量的\r\n
5.持久化方式：1.RDB快照，多进程写时复制COW
             2.AOF日志，修改性指令序列，“重放”，先执行指令再降日志存盘，
			   AOF重写：启用一个子进程对内存遍历，转换成一系列redis操作指令，序列化到一个新的日志文件中，完毕后进行增量追加
			   注意：（延迟写delayed write）AOF日志是内核为文件描述符分配了一个缓冲区，内核会异步写入磁盘，可以调用fsync(int fd)实时刷新到磁盘，每隔1s
			        刷新一次，时间可配置
6.Redis管道技术：在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取
				所有服务器的响应
7.Redis事务：begin commit rollback
  对应redis命令：multi指示事务的开始，exec指示事务的执行，discard指示事务丢弃
8.分布式锁：悲观锁 
  Watch机制：乐观锁，观察某个变量在事务操作前后是否改过，禁止在multi和exec之间使用Watch

*/